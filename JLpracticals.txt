-------------------------------------------------------------------------------------NUMA (Non-Uniform Memory Access)---------------------------------------------------------------------------- 

1. Why would you want to use one NUMA Domain over another?

 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

2. How would you pin a process to a specific Core to make use of a NUMA Domain?

 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

3. What is DMA (Direct Memory Access) and what are the pros and cons of using DMA for kernel bypass vs using the kernel?

 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


4. What does a "cache miss" signify? How would you detect it?


-----------------------------------------------------------------------------------------------------Ansible-------------------------------------------------------------------------------------------

5. Investigate `ansible-pull` and consider the pros and cons of push vs pull when it comes to configuration management.




 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


6. Review the code below and understand its components:
   ```
   sudo ansible-pull -U https://github.com/caffeineaddiction/profile_setup.git -C "master" -e "target_user=${SUDO_USER:-$(whoami)}" --skip-tags vault -i localhost, setup.yml
   ```

 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


7. How would you get this to default the shell to `zsh` rather than `fish`?






 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


8. What are the pros and cons of making a change to `~/.bashrc` rather than setting the shell in `/etc/passwd`?





 ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------




-------------------------------------------------------------Command-Line Efficiency-----------------------------------------------------------------------------------------------------------------------

9. Try using `grep` with history (bonus points if you can use regex).

Search for cp, mv, or rm commands followed by a file path:
history | grep -E '(cp|mv|rm)\s+/[^\s]+'

Search for kubectl or helm commands with subcommands:
history | grep -E 'kubectl\s+\w+|helm\s+\w+'

examples of using or operating with grep:
history | grep -E 'docker|docker-compose'
history | grep -E 'cp|mv|rm'
history | grep -E 'ssh|scp'
history | grep -E 'git|github'
history | grep -E 'kubectl|helm'

docker(-compose)?(\s+--\w+)*:

docker(-compose)?: Matches docker or docker-compose.
(\s+--\w+)*: Matches zero or more occurrences of space followed by -- and a word.
(cp|mv|rm)\s+/[^\s]+:

(cp|mv|rm): Matches cp, mv, or rm.
\s+/[^\s]+: Matches a space followed by a / and one or more non-space characters (a file path).
(ssh|scp)\s+\w+@[\w.-]+:

(ssh|scp): Matches ssh or scp.
\s+\w+@[\w.-]+: Matches a space followed by a word, an @, and a host (e.g., user@hostname).
git\s+(clone|pull)\s+https?://[\w./-]+:

git\s+(clone|pull): Matches git followed by a space and clone or pull.
\s+https?://[\w./-]+: Matches a space followed by http:// or https:// and a URL.
kubectl\s+\w+|helm\s+\w+:

kubectl\s+\w+: Matches kubectl followed by a space and a word (subcommand).
helm\s+\w+: Matc


               grep [options] PATTERN [FILE...] 
               grep "pattern" filename
               grep "pattern" file1 file2 file3
               grep -r "pattern" directory/ recursive search of all files in the directory and subdirectories
               grep -i "pattern" filename case-insensitive search
               grep -n "pattern" filename display line number in front of the matched line
               grep -v "pattern" filename display all the lines that do not match/inverts search


               grep options:
               -i: Ignore case distinctions in patterns and data.
               -v: Invert the match, showing lines that do not match the pattern.
               -r or -R: Recursively search directories.
               -l: Print only the names of files with matching lines.
               -n: Prefix each line of output with the line number within its input file.
               -e: Specify multiple patterns to match.
               -w: Match whole words only.    
               -c: Print only a count of the lines that match.
               -o: Show only the part of a line that matches the pattern.
               -A NUM: Print NUM lines of trailing context after matching lines.
               -B NUM: Print NUM lines of leading context before matching lines.
               -C NUM: Print NUM lines of output context.
               -f FILE: Read one or more newline-separated patterns from a file.
               -q: Quiet mode: suppress normal output. grep will only search for the pattern and return a 0 exit status if it is found.
               -s: Suppress error messages about nonexistent or unreadable files.
               -x: Match whole lines only.
               
               examples:
               head -n 10 draft_players.csv = cat draf_players.csv | head -n 10 #but this only works on logs and not on files
               tail -n 10 draft_players.csv = cat draf_players.csv | tail -n 10



   so to use grep with history would mean to use grep with the terminal history file.
   need to give the history as the file and then a pattern to search for.  
    
   First lets try using grep on a file with a simple patter of "grep" and see what it returns.
   > grep "grep" JL_practicals.txt 
  

   Now lets try using grep with the history file without using the pipe operator.

   > grep "grep" ~/.bash_history 
      kubectl describe daemonset aws-node -n kube-system | grep Image
      ps aux | grep python

   Quick review of using the pipe | operator with grep:

   Command: ps aux | grep python
         ps aux:

         ps: The command to display information about active processes.
         aux: Options to show detailed information about all running processes:
         a: Shows processes for all users.
         u: Displays the processes in a user-oriented format.
         x: Includes processes that are not attached to a terminal.
         This command lists all running processes on the system with detailed information such as user, PID, CPU usage, memory usage, and command.

         | grep python:

         |: The pipe operator takes the output of the command on its left and passes it as input to the command on its right.
         grep python: Searches for lines containing the word "python" in the input it receives.
         Effect: This command filters the list of all running processes to show only the lines that contain the word "python". This is useful for quickly finding all Python processes running on the system.

 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


10. Create a `~/.ssh/config` and figure out how to:
   - Give an entry a nickname.

   #below are some configs pulled from my .ssh/config file
   
   # Configuration for your EC2 server...this is not live old ec2 and key
Host RoyaleWithCheese
    HostName ec2-34-229-231-169.compute-1.amazonaws.com
    User ubuntu
    IdentityFile ~/.ssh/devops-ew.pem
    IdentitiesOnly yes
    UseKeychain yes


#testing for bravo this is not live
Host test
    HostName 54.236.14.106
    Port 22
    User ubuntu
    IdentityFile ~/.ssh/test.pem

Configure browser proxy settings to use dynamic port forwarding through SSH:

For Firefox:

Open Firefox and go to Preferences (or Options).
Scroll down to Network Settings and click on Settings.
Select Manual proxy configuration.
In the SOCKS Host field, enter localhost and set the Port to 1080.
Ensure SOCKS v5 is selected.
Click OK to save the settings.
For Google Chrome:

Chrome does not have built-in proxy settings, so you need to use system proxy settings.
On macOS, go to System Preferences > Network.
Select your active network connection and click on Advanced.
Go to the Proxies tab.
Check the SOCKS Proxy box and enter localhost for the SOCKS Proxy Server and 1080 for the Port.
Click OK and then Apply.
For Safari:

Open Safari and go to Preferences.
Go to the Advanced tab and click on Proxies: Change Settings.
This will open the system proxy settings (same as Chrome).
Follow the same steps as for Chrome to configure the SOCKS proxy.
Verify the Configuration:

After configuring browser, visit a website like https://www.whatismyip.com/ to check your external IP address.
It should now show the IP address of the remote server, indicating that your traffic is being routed through the SSH tunnel.


   - Set up Dynamic Port Forwarding (bonus points if you can proxy your browser through it so that your external IP appears as the remote box).
   - Use jumphosting like `ProxyCommand ssh -W %h:%p jump-host` and understand why it might be useful.

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


11. See if you can update your `$PATH` to prioritize binaries in `~/bin/` before the system binaries, and consider why this might be useful.

     So to update the $PATH to prioritize binaries in ~/bin/ before the system binaries the key is understanding order matters:  

     The $PATH environment variable in Unix-like operating systems, including macOS and Linux, determines the order in which directories are searched for executable files (binaries). The order of directories in the $PATH variable is significant because it dictates the priority of binaries when you execute a command.

      Understanding $PATH Priority

      - Order Matters: Directories listed earlier in the $PATH variable have higher priority. If two directories contain binaries with the same name,  the binary in the directory listed first in $PATH will be executed.

      Why This Might Be Useful:

      - Custom Scripts: Prioritizing ~/bin allows you to easily run custom scripts and binaries without needing to specify their full path.
      - Overriding System Binaries: You can override system binaries with your own versions by placing them in ~/bin.
      - User-Specific Customization: It provides a way to customize your environment without affecting other users on the system.

      *****************
      In a high-speed trading firm, prioritizing binaries in ~/bin/ over system binaries can have several practical applications. Here are some specific use cases where this configuration might be useful:

         1. Custom Optimized Trading Algorithms

            •	Scenario: Traders and engineers at a high-speed trading firm might develop highly optimized trading algorithms or custom scripts that are performance-tuned for the firm’s infrastructure.
            •	Use Case: Placing these custom algorithms or scripts in ~/bin/ and prioritizing them over system binaries ensures the firm’s specific optimizations take precedence when executed. This can lead to faster execution times and better performance in low-latency trading environments, critical for high-frequency trading.

         2. Overriding System Libraries with Lower Latency Versions

            •	Scenario: A trading firm may require custom-built versions of libraries like curl, openssl, or networking tools that have been optimized for the firm’s low-latency requirements.
            •	Use Case: Prioritizing ~/bin/ allows the firm’s optimized versions of these libraries to be used over the default system libraries. For example, an internally modified curl binary could fetch market data faster than the standard version, giving traders an edge in high-speed execution.

         3. Testing Newer Versions of Software

            •	Scenario: Trading engineers might need to test or use newer versions of software than those provided by the system, for example, newer versions of gcc or Python with optimizations specific to high-performance computing.
            •	Use Case: Placing these newer versions in ~/bin/ allows the trading engineers to easily switch between the default system binaries and the custom versions. This flexibility is important in a trading environment where testing new versions of compilers or libraries might lead to performance improvements.

         4. Security Enhancements for Sensitive Operations

            •	Scenario: In a trading firm, security is paramount, especially when handling sensitive financial data.
            •	Use Case: The firm might deploy custom versions of security-related binaries (e.g., ssh, scp, or openssl) that have been enhanced with additional encryption algorithms or patches. Prioritizing these in ~/bin/ ensures that sensitive operations always use the firm’s secure versions, overriding potentially outdated system binaries.

         5. Quick Rollback of Updates

            •	Scenario: If an update to a system binary negatively impacts performance or functionality in a high-frequency trading environment, the ability to quickly revert to a previous version is critical.
            •	Use Case: By maintaining a set of backup binaries in ~/bin/, engineers can quickly switch back to known, stable versions of key binaries without modifying the system-wide configuration, minimizing downtime and ensuring the trading system stays operational.

         6. Low-Latency Market Data Processing

            •	Scenario: Real-time processing of market data is essential for high-speed trading.
            •	Use Case: Custom binaries in ~/bin/ may be used to fetch, parse, and process data feeds faster than the default system utilities. By ensuring these custom binaries have higher priority, market data can be processed with minimal delay, giving the firm a competitive advantage in trade execution.

         7. High-Performance Networking Tools

            •	Scenario: High-speed trading firms rely heavily on low-latency networking tools to connect with exchanges and trading platforms.
            •	Use Case: Custom networking binaries (e.g., an optimized version of ping, ifconfig, or tcpdump) could be placed in ~/bin/ to ensure these tools, which have been optimized for latency, are used instead of the system defaults. This allows for more accurate and faster diagnostics of network performance, a key factor in high-frequency trading.

         8. User-Specific Debugging Tools

            •	Scenario: Developers working in a high-speed trading firm might create custom debugging or logging tools tailored to their system.
            •	Use Case: Placing these custom tools in ~/bin/ allows for quick access during debugging sessions, ensuring they are used instead of any system-provided alternatives, making it easier to capture precise logs or trace data in a high-performance environment.

         By configuring the $PATH to prioritize ~/bin/, trading engineers and developers can ensure their firm-specific tools, optimizations, and performance enhancements are executed first, which is critical in the fast-paced, low-latency world of high-frequency trading.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 